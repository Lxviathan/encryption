<?php namespace Illuminate;

class DecryptionException extends \Exception {}

class Encrypter {

	/**
	 * The cipher to be used during encryption.
	 *
	 * @var string
	 */
	protected $cipher;

	/**
	 * The mode to be used when encrypting.
	 *
	 * @var string
	 */
	protected $mode;

	/**
	 * The encryption key.
	 *
	 * @var string
	 */
	protected $key;

	/**
	 * Create a new encrypter instance.
	 *
	 * @param  string  $cipher
	 * @param  string  $model
	 * @param  string  $key
	 * @return void
	 */
	public function __construct($cipher, $mode, $key)
	{
		$this->key = $key;
		$this->mode = $mode;
		$this->cipher = $cipher;
	}

	/**
	 * Encrypt the given value.
	 *
	 * @param  string  $value
	 * @return string
	 */
	public function encrypt($value)
	{
		$iv = mcrypt_create_iv($this->getIvSize(), $this->getRandomizer());

		// We'll pad the value with PKCS7 compataible padding, which basically
		// means the value will be padded with a byte whose value is equal
		// to the number of bytes needed to complete the block size.
		$value = $this->pad($value);

		$value = mcrypt_encrypt($this->cipher, $this->key, $value, $this->mode, $iv);

		return base64_encode($iv.$value);
	}

	/**
	 * Decrypt the given value.
	 *
	 * @param  string  $value
	 * @return string
	 */
	public function decrypt($value)
	{
		$iv_size = $this->getIvSize();

		$value = base64_decode($value);

		// We need to extract the input vector from the encrypted value so
		// we'll slice the string based on the size of the vector for
		// the cipher and mode that was used during encryption.
		$iv = substr($value, 0, $iv_size);

		$value = substr($value, $iv_size);

		$value = mcrypt_decrypt($this->cipher, $this->key, $value, $this->mode, $iv);

		// We need to remove the PKCS7 padding from the decrypted value as
		// this is added by the encrypt method to ensure that the value
		// is cross-comptaible with various other encryption methods.
		return $this->unpad($value);
	}

	/**
	 * Add PKCS7 compatible padding on the given value.
	 *
	 * @param  string  $value
	 * @return string
	 */
	protected function pad($value)
	{
		$block = $this->getBlockSize();

		$pad = $block - (strlen($value) % $block);

		return $value .= str_repeat(chr($pad), $pad);
	}

	/**
	 * Remove the PKCS8 compatible padding from the given value.
	 *
	 * @param  string  $value
	 * @return string
	 */
	protected function unpad($value)
	{
		$pad = ord($value[($length = strlen($value)) - 1]);

		if ($pad and $pad < $this->getBlockSize())
		{
			// If the correct padding is present on the string we will remove it and
			// return the value. Otherwise, we'll throw an exception as it appears
			// that the encrypted value has been changed since it was generated.
			if (preg_match('/'.chr($pad).'{'.$pad.'}$/', $value))
			{
				return substr($value, 0, $length - $pad);
			}

			// If the padding characters do not match the expected padding value for
			// the encrypted value, we will throw an excpetion as the value seems
			// to have changed since it was generated by the encrypt function.
			else
			{
				throw new \DecryptionException("Decryption error. Padding is invalid.");
			}
		}

		return $value;
	}

	/**
	 * Get the appropriate random number source.
	 *
	 * @return int
	 */
	protected function getRandomizer()
	{
		// There are several sources from which we can get random numbers
		// and we will choose the most secure source depending on the
		// server environment and what is available to the script.
		if (defined('MCRYPT_DEV_URANDOM'))
		{
			return MCRYPT_DEV_URANDOM;
		}
		elseif (defined('MCRYPT_DEV_RANDOM'))
		{
			return MCRYPT_DEV_RANDOM;
		}

		// When using the default / system random number generator we'll
		// seed the number genrator on each call to ensure the given
		// results come as random as we can possibly make them.
		else
		{
			mt_srand();

			return MCRYPT_RAND;
		}
	}

	/**
	 * Get the input vector size for the cipher and mode.
	 *
	 * @return int
	 */
	protected function getIvSize()
	{
		return mcrypt_get_iv_size($this->cipher, $this->mode);
	}

	/**
	 * Get the proper block size for the cipher and mode.
	 *
	 * @return int
	 */
	protected function getBlockSize()
	{
		return mcrypt_get_block_size($this->cipher, $this->mode);
	}

}